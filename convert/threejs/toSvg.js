import * as THREE from 'three';
import { DOMParser, XMLSerializer } from 'xmldom';
import { installProjector } from './Projector';
import { installSVGRenderer } from './SVGRenderer';
import { toKeptGeometry } from '@jsxcad/geometry-tagged';
import { toThreejsGeometry } from './toThreejsGeometry';

// Bootstrap start.
const { Projector, RenderableFace, RenderableLine, RenderableSprite } = installProjector({ THREE });

const { SVGRenderer } = installSVGRenderer({ THREE, Projector, RenderableFace, RenderableLine, RenderableSprite, document: new DOMParser().parseFromString('<xml></xml>', 'text/xml') });
// Bootstrap done.

const build = ({ view = {}, pageSize = [100, 100], grid = false }, geometry) => {
  const { target = [0, 0, 0], position = [40, 40, 40], up = [0, 0, 1] } = view;
  const [pageWidth, pageHeight] = pageSize;
  const camera = new THREE.PerspectiveCamera(27, pageWidth / pageHeight, 1, 3500);
  [camera.position.x, camera.position.y, camera.position.z] = position;
  camera.up = new THREE.Vector3(...up);
  camera.lookAt(...target);
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  scene.add(camera);
  if (grid) {
    const grid = new THREE.GridHelper(100, 10, 'green', 'blue');
    grid.material = new THREE.LineBasicMaterial({ color: 0x000000 });
    grid.rotation.x = -Math.PI / 2;
    // grid.material.transparent = true;
    scene.add(grid);
  }
  //
  var ambientLight = new THREE.AmbientLight(0x222222);
  scene.add(ambientLight);
  var light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 1, 1);
  camera.add(light);

  const walk = (geometry) => {
    if (geometry.assembly) {
      geometry.assembly.forEach(walk);
    } else if (geometry.threejsPoints) {
      const points = geometry.threejsPoints;
      const threejsGeometry = new THREE.Geometry();
      const material = new THREE.PointsMaterial({ color: 0x0000ff });
      for (const [x, y, z] of points) {
        threejsGeometry.vertices.push(new THREE.Vector3(x, y, z));
      }
      scene.add(new THREE.Points(threejsGeometry, material));
    } else if (geometry.threejsSegments) {
      const segments = geometry.threejsSegments;
      const threejsGeometry = new THREE.Geometry();
      const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
      for (const [[aX, aY, aZ], [bX, bY, bZ]] of segments) {
        threejsGeometry.vertices.push(new THREE.Vector3(aX, aY, aZ), new THREE.Vector3(bX, bY, bZ));
      }
      scene.add(new THREE.LineSegments(threejsGeometry, material));
    } else if (geometry.threejsSolid) {
      const { positions, normals } = geometry.threejsSolid;
      const threejsGeometry = new THREE.BufferGeometry();
      threejsGeometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      threejsGeometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      const material = new THREE.MeshNormalMaterial();
      scene.add(new THREE.Mesh(threejsGeometry, material));
    } else if (geometry.threejsSurface) {
      const { positions, normals } = geometry.threejsSurface;
      const threejsGeometry = new THREE.BufferGeometry();
      threejsGeometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      threejsGeometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      const material = new THREE.MeshNormalMaterial();
      scene.add(new THREE.Mesh(threejsGeometry, material));
    }
  };
  walk(toThreejsGeometry(geometry));

  return [scene, camera];
};

export const toSvg = async (options = {}, geometry) => toSvgSync(options, geometry);

const header =
`<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by jsxcad -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">
`;

export const toSvgSync = (options = {}, geometry) => {
  const [scene, camera] = build(options, toKeptGeometry(geometry));
  const { includeXmlHeader = true, pageSize = [500, 500] } = options;
  const [pageWidth, pageHeight] = pageSize;

  const renderer = new SVGRenderer({});
  renderer.setSize(pageWidth, pageHeight);
  renderer.render(scene, camera);

  const serializer = new XMLSerializer();
  let svg = serializer.serializeToString(renderer.domElement) + '\n';
  if (includeXmlHeader) {
    svg = header + svg;
  }
  return svg;
};
